# -*- coding: utf-8 -*-
"""streamlit_dashboard_app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iBmWX_2Mzc8ZU-KUzW_ZjSqdevE8yOT-
"""

import pandas as pd

from lightgbm import LGBMClassifier

"""
Created on Wed Jul 06 21:30 2022"
@author: Konan.Donatien
"""
# ===================== Importation des librairies =============================
import requests
import streamlit as st

# ===================== Importation des module =================================
from data_pulling import PlotterModule
from streamlit_webpage_plotter import StreamlitWebpagePlotter
from cachetools import cached, TTLCache


# =========================== import de donnée =================================


cache = TTLCache(maxsize=100, ttl=100)
cache_1 = TTLCache(maxsize=100, ttl=100)
cache_2 = TTLCache(maxsize=100, ttl=100)


@cached(cache)
def data():
    datas = datapulling.gt_data
    return datas


@cached(cache_1)
def shap_values():
    shap_vals = datapulling.shap_val
    return shap_vals


@cached(cache_2)
def model():
    model_ = datapulling.gt_model()
    return model_


@st.cache_resource(max_entries=100)
def get_api_routes(URL):
    return URL


# URLs de connexion de l'API FastAPI

API_URL_MODEL_PARAMS = "http://127.0.0.1:8000/get_model_params"
API_URL_CREDIT = "http://127.0.0.1:8000/get_credit"
API_URL_DATA = "http://127.0.0.1:8000/get_data"

API_URL_FILTER_BY_ID = "http://127.0.0.1:8000/get_filter_data_by_id"


# ================ Rendre disponible les données via l'api FastAPI =============


@st.cache_data(ttl=100, max_entries=100)
def get_model_params_from_api():
    response = requests.get(API_URL_MODEL_PARAMS)

    if response.status_code == 200:
        response = response.json()
        response = response.get("model_params")

        return response

    else:
        st.error("Impossible de récupérer le modèle depuis l'API.")
        return None


@st.cache_data(ttl=100, max_entries=100)
def get_data():
    response_2 = requests.get(API_URL_DATA)
    response_2 = response_2.json()
    response_2 = response_2.get("data")
    response_2 = pd.DataFrame(response_2)
    return response_2


@st.cache_data(ttl=5, max_entries=100)
def class_score(ID_):
    response_3 = requests.get(API_URL_CREDIT, params={"ID": ID_})  # val_score et class_ca
    response_3 = response_3.json()

    return response_3


@st.cache_data(ttl=10, max_entries=100)
def get_filter_data_by_idx(ID_):
    response_1 = requests.get(API_URL_FILTER_BY_ID, params={"ID": ID_})  # appel dt
    response_1 = response_1.json()

    return response_1.get("get_filter_data_by_id")


# Récupération du modèle depuis l'API

# Instanciation
datapulling = PlotterModule()

image = datapulling.logo()


# reconstruction du model via l'API

model_param = get_model_params_from_api()
our_model = LGBMClassifier(**model_param)

# our_data = get_data()
our_data = data()
shap_value_result = shap_values()

sw = StreamlitWebpagePlotter(our_data, shap_value_result)

# Utilisation du modèle dans Streamlit
if our_model:
    st.write("Modèle récupéré avec succès depuis l'API :")
    # Utilisez le modèle dans votre application Streamlit selon vos besoins
else:
    st.error("Erreur lors de la récupération du modèle depuis l'API.")

# COMMUNICATION AVEC l'API

# ============== Exécution sdes fonctions d'affichage ==========================


st.write("Dashboard réalisé par Donatien KONAN, Data Scientist")
st.title("DASHBOARD - VISUALISATION - STATISTIQUE CREDIT")

st.sidebar.image(image, use_column_width=True)

ID = st.number_input("Veuillez saisir un identifiant client ici :",
                     key=int, step=1)
if ID not in our_data.index:
    st.write("Veuillez saisir un identifiant client valide pour l'analyse")

else:

    req = class_score(ID)
    val_score = req.get("score")
    class_cat = req.get("Demande de crédit")

    # éviter l'affichage d'erreur pyplot
    st.set_option('deprecation.showPyplotGlobalUse', False)

    st.sidebar.title("Navigation")
    options = st.sidebar.radio("Types d'analyse",
                               options=["Score du client et Interprétabilité de décision",
                                        "Distribution statistique de caractéristiques",
                                        "Relation entre caractéristiques"]
                               )

    dt_idx = our_data.query(f"index=={ID}")

    if options == "Score du client et Interprétabilité de décision":

        sw.gauge(ID, class_cat, val_score)
        sw.local_interpret(ID)
        global_ = st.checkbox("Afficher l'interprétabilité globale")
        if global_:
            sw.global_interpret()

    elif options == "Distribution statistique de caractéristiques":
        sw.interactive_hist_plot(ID, dt_idx)

    elif options == "Relation entre caractéristiques":
        sw.interactive_scatter_plot(ID, dt_idx, val_score)

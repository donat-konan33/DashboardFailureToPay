# -*- coding: utf-8 -*-
"""streamlit_webpage_plotter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mBCy_hJ_MF8Idmm67Aa_gipnvhaRfL82
"""
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
import shap


# ================= Définition des fonctions d'affichage =======================
class StreamlitWebpagePlotter:
    # Initialisation
    def __init__(
            self,
            data,
            shap_values
    ):
        """
    data de données en sortie Json
    shap_values supposé être un tableau contenant les valeur de Shapley
    shap_values_idx : valeur de Shapley pour un individu donné ayant l'index idx
    dt : attributs selon l'identifiant ID

    """
        self.data = data
        self.shap_values = shap_values
        self.fig_gauge = None

    def gauge(
            self,
            ID: int,
            class_cat,
            val_score
    ):
        """
        class_cat : la classe du client (demande acceptée ou réfusée)
        val_score : le score en pourcentage

        """

        st.header("Score statistique du client n°{}".format(ID))
        st.subheader("Décision: Demande de crédit {}".format(class_cat))
        st.write("La probabilté de défaut de paiement du client est de ",
                 round(val_score, 2), "%")

        fig = go.Figure(go.Indicator(
            mode="gauge+number",
            value=val_score,
            domain={'x': [0, 1], 'y': [0, 1]},
            title={'text': "SCORE"},
            gauge={'axis': {'range': [None, 100]},
                   'steps': [
                       {'range': [0, 50], 'color': "white"},
                       {'range': [50, 100], 'color': "gray"}
                   ],
                   'bar': {'color': ["green" if val_score <= 50 else "red"][0]},
                   'bgcolor': "white",
                   'borderwidth': 2,
                   'bordercolor': "gray",
                   'threshold': {'line': {'color': "red", 'width': 4},
                                 'thickness': 0.75, 'value': 50}}))

        self.fig_gauge = fig
        return st.plotly_chart(fig), st.write("(*) Ce score représente la probabilité de défaut de paiement")

    # Interprétabilité locale du modèle

    def local_interpret(
            self,
            ID: int
    ):
        """
    self.shap_values_idx est identique à shap_values[idx]
    où idx est l'index correspondant à l'identifiant dans le dataframe

    """
        st.subheader("Interprétabilité locale du modèle")
        max_display = st.slider("Nombre de caractéristiques à afficher",
                                10, 40, 10, key="w1")

        # définition de l'indice en fonction de l'ID
        index_list = self.data.index.tolist()
        idx: int = index_list.index(ID)
        shap_value = self.shap_values

        fig = shap.plots.waterfall(shap_value[idx], max_display=max_display)
        return st.pyplot(fig)

    # Ajout de l'interprétabilité globale

    def global_interpret(self) -> object:
        st.subheader("Interprétabilité globale du modèle")
        max_display = st.slider("Nombre de caractéristiques à afficher",
                                10, 40, 10, key="w2")
        fig = shap.plots.bar(self.shap_values, max_display=max_display)
        return st.pyplot(fig)

    # interactive_plot, histogramme
    def interactive_hist_plot(self,
                              ID: int,
                              dt):
        """
      dt : data[data.index == ID] sortant en json,
      données du client considéré

      class_cat : la classe du client dont l'identifiant est ID

      """

        st.subheader("Affichage d'une distribution statistique")
        feature = st.selectbox("Veuillez choisir une caratéristique",
                               options=["AMT_INCOME_TOTAL", "EXT_SOURCE_3",
                                        "EXT_SOURCE_2", "EXT_SOURCE_1",
                                        "DAYS_EMPLOYED", "AMT_ANNUITY"])
        fig = px.histogram(self.data, x=feature, color="class_cat", marginal="rug",
                           hover_data=self.data.columns)  # hover_data est de types Series ici
        # idx = data_predict.index.tolist().index(ID)
        # dataframe d'une occurence liée à un ID
        fig.add_trace(go.Histogram(
            x=dt[feature],
            name='client {}'.format(ID),
            opacity=1,
            marker_color='#fff000',
            hovertemplate="<b>%{text}</b>",
            text=[
                'class_cat : {}, {}={}'.format(
                    dt["class_cat"].values[0],
                    feature,
                    round(dt[feature].values[0], 7)
                )
            ]
        )
        )

        text = "Ce client appartient à cette population"
        fig.add_annotation(
            x=dt[feature].values[0],
            y=50,
            xref="x",
            yref="y",
            text=text,
            showarrow=True,
            font=dict(
                family="Courier New, monospace",
                size=16,
                color="#000000"
            ),
            align="center",
            arrowhead=2,
            arrowsize=1,
            arrowwidth=2,
            arrowcolor="#e6e64c",
            ax=70,
            ay=-100,
            bordercolor="#000000",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ffffff",
            opacity=1
        )
        fig.update_layout(autosize=False, width=800, height=700,
                          title_text='Distribution selon {}'.format(feature))

        st.plotly_chart(fig)

        impact = st.checkbox("Afficher l'impact de la caractéristique choisie sur la prise de décision du modèle")
        if impact:
            fig_ = px.scatter(self.data, x=self.shap_values[:, feature].values,
                              y=feature, color="class_cat",
                              color_continuous_scale='rdbu_r',
                              labels={"x": "Contribution à la probabilité de défaut de paiement"})

            st.plotly_chart(fig_)  # vérifier la compatibilité entre les version de streamlit et plotly

    # interactive_plot, Nuage de points
    def interactive_scatter_plot(self,
                                 ID: int,
                                 dt,
                                 val_score):
        """
      dt : data[data.index == ID] au format Json, données du client considéré
      val_score : score (%)

      """
        st.subheader("Affichage de la relation entre 2 caractéristiques")
        x_axis_val = st.selectbox("Veuillez choisir l'abscisse",
                                  options=["AMT_INCOME_TOTAL", "EXT_SOURCE_3",
                                           "EXT_SOURCE_2", "EXT_SOURCE_1",
                                           "DAYS_EMPLOYED", "AMT_ANNUITY"])

        y_axis_val = st.selectbox("Veuillez choisir l'ordonnée",
                                  options=["AMT_INCOME_TOTAL", "EXT_SOURCE_3",
                                           "EXT_SOURCE_2", "EXT_SOURCE_1",
                                           "DAYS_EMPLOYED", "AMT_ANNUITY"])

        fig = px.scatter(self.data, x=x_axis_val, y=y_axis_val, color="score",
                         color_continuous_scale='rdbu_r')

        trace = go.Scatter(x=dt[x_axis_val],
                           y=dt[y_axis_val],
                           line_color='yellow',
                           name="client {}".format(ID),
                           visible=True, mode="lines+markers",
                           marker={"size": 20},
                           fillcolor="white",
                           hovertemplate='<b>%{text}</b>',
                           text=[
                               "{}={}, {}={}, score={}".format(
                                   x_axis_val,
                                   round(dt[x_axis_val].values[0], 7),
                                   y_axis_val,
                                   round(dt[y_axis_val].values[0], 7),
                                   round(val_score, 7))
                           ]
                           )

        # give it a legend group and hide it from the legend
        trace.update(legendgroup="trendline", showlegend=False)

        # add it to all rows/cols, but not to empty subplots
        fig.add_trace(trace, row="all", col="all", exclude_empty_subplots=True)

        text = "Votre client est ici"
        fig.add_annotation(
            x=dt[x_axis_val],
            y=dt[y_axis_val],
            xref="x",
            yref="y",
            text=text,
            showarrow=True,
            font=dict(
                family="Courier New, monospace",
                size=16,
                color="#000000"
            ),
            align="center",
            arrowhead=2,
            arrowsize=1,
            arrowwidth=2,
            arrowcolor="#c40c3a",
            ax=70,
            ay=-100,
            bordercolor="#000000",
            borderwidth=2,
            borderpad=4,
            bgcolor="#ffffff",
            opacity=1
        )
        fig.update_layout(autosize=False,
                          width=800, height=700,
                          margin=dict(
                              l=50,
                              r=50,
                              b=100,
                              t=100,
                              pad=4)
                          )
        return st.write(fig)  # vérification de compatibilité de plotly et de streamlit
